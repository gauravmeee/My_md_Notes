

# Original

Here’s a **line-by-line, token-by-token detailed explanation** of your LEA-like encryption/decryption code:

---

###### **1. Importing Libraries**
```python
import struct
import time
```

- `import struct`: Used for converting between Python values and C structs (e.g., packing/unpacking bytes and integers).
- `import time`: Imported but **not used** in this code. ❗

235


###### **2. Bit Rotation Functions**

```python
def rol(x, r):
    return ((x << r) | (x >> (32 - r))) & 0xFFFFFFFF
```
- `rol`: **rotate left** operation.
- `x << r`: shift `x` left by `r` bits.
- `x >> (32 - r)`: shift `x` right by `32 - r` bits.
- `|`: bitwise OR merges the rotated parts. 
- `& 0xFFFFFFFF`: ensures the result is 32-bit (clears higher bits). 

- `0xFFFFFFFF` is a **hexadecimal constant** representing the **32-bit unsigned integer** with all bits set to 1.
	- **`0x`** → This prefix means the number is in **hexadecimal (base 16)** format.
	- **`FFFFFFFF`** → These are 8 hexadecimal digits:
    - Each hex digit = 4 bits i.e. 
    - `8 digits × 4 bits = 32 bits` 
    - (`0` =`0000`,..., `9=1001`, `A`=`1010`,..., `F`=`1111`)
- In **binary**, `0xFFFFFFFF` = `11111111 11111111 11111111 11111111`
- In **decimal**, it equals `4294967295` (which is the **maximum value for 32-bit unsigned int**).
    

```python
def ror(x, r):
    return ((x >> r) | (x << (32 - r))) & 0xFFFFFFFF
```
- `ror`: **rotate right** operation.
- Same logic, but rotation is to the right.
    
###### **3. Converting Between Bytes and 32-bit Words**

```python
def bytes_to_words(b):
    return list(struct.unpack('<4I', b))
```
- encryption works on 128-bit blocks
	- 128 bits = 4 x 32-bit words = 16 bytes
- `b`: **16 bytes** (the size of 4 32-bit integers).
- `'<4I'`: unpack **4 little-endian unsigned ints (32-bit)**.
	- The `<` indicates the **byte order** (endianness) : **Little-endian** means that the **least significant byte** (LSB) comes first, followed by the more significant bytes.
	- **`4I`** means "4 unsigned 32-bit integers." where **`I`** stands for an **unsigned integer**.

- `struct.unpack`: Converts bytes → tuple of ints.
	- `struct.unpack('<4I', b)`, it means you are interpreting the **16-byte input (`b`)** as **4 integers** (each 32 bits long), using little-endian byte order.
- `list(...)`: Converts to list of 4 integers.

```python
def words_to_bytes(w):
    return struct.pack('<4I', *w)
```
- `*w`: unpacks list of 4 integers into args.
- `struct.pack`: Converts list of 4 ints → 16 bytes.
    
###### **4. LEA-Like Encryption of 16-byte Block**

```python
def lea_encrypt_block(block, round_keys):
    X = bytes_to_words(block)
```
- Convert input `block` (16 bytes) into list `X` of 4 words (32-bit).

**Diffusion :**
```python
    X[0] ^= X[1]
    X[1] ^= X[2]
    X[2] ^= X[3]
    X[3] ^= X[0]
```
- Initial mixing using XOR to diffuse data before rounds.
    

```python
    for rk in round_keys:
```
- **`round_keys`** is a list (or sequence) of **round keys** , generated by a key schedule in encryption algorithms.
- **`rk`**: This is a variable representing each **round key** as the loop iterates over
- Loop over each round key (list of 4 integers).

```python
        X[0] = rol((X[0] + (X[1] ^ rk[0])) & 0xFFFFFFFF, 3)
        X[1] = rol((X[1] + (X[2] ^ rk[1])) & 0xFFFFFFFF, 5)
        X[2] = rol((X[2] + (X[3] ^ rk[2])) & 0xFFFFFFFF, 9)
        X[3] = rol((X[3] + (X[0] ^ rk[3])) & 0xFFFFFFFF, 11)
```
- `X[i+1] ^ rk[i]`: combine state + round key.
- Add to `X[i]`, mod `2^32`, then rotate left by 3 bits.
- `X[i]` = ( ( `X[i+1]` XOR `rk[i]`  ) -> Add `X[i]` ) -> Rotation Left

**Diffusion**
```python
        X[0] ^= rol(X[2], 7)
        X[1] ^= rol(X[3], 11)
        X[2] ^= rol(X[0], 13)
        X[3] ^= rol(X[1], 17)
```
- Additional mixing: Rotate and XOR with other parts of state to strengthen diffusion.
    
```python
    return words_to_bytes(X)
```
- Convert back the encrypted 4-word state into 16-byte block.


###### **5. LEA-Like Decryption of 16-byte Block**

```python
def lea_decrypt_block(block, round_keys):
    X = bytes_to_words(block)
```

```python
    for rk in reversed(round_keys):
```
- Reverse rounds for decryption.
    
```python
        X[3] ^= rol(X[1], 17)
        X[2] ^= rol(X[0], 13)
        X[1] ^= rol(X[3], 11)
        X[0] ^= rol(X[2], 7)
```
- Undo additional mixing (same order as applied during encryption).
- **Why Decryption also use rol (not ror) here?**
	- This is **XOR operations with rotated values** (Not Exactly same thing but reverse).
	- These operations **reverse the effect** of the corresponding rotations performed during encryption.

```python
        X[3] = (ror(X[3], 11) - (X[0] ^ rk[3])) & 0xFFFFFFFF
        X[2] = (ror(X[2], 9) - (X[3] ^ rk[2])) & 0xFFFFFFFF
        X[1] = (ror(X[1], 5) - (X[2] ^ rk[1])) & 0xFFFFFFFF
        X[0] = (ror(X[0], 3) - (X[1] ^ rk[0])) & 0xFFFFFFFF
```
- Undo round function: reverse order of operations — rotate right, subtract round key influence. ❓
    
```python
    X[3] ^= X[0]
    X[2] ^= X[3]
    X[1] ^= X[2]
    X[0] ^= X[1]
```
- Reverse the initial XOR mixing.
- **Why Exactly Same Operation for Encryption Decryption  Reverse the Effect?** 
	- In cryptography, **XOR** is a reversible operation. When you apply XOR twice with the same value, it effectively cancels itself out:
	- A⊕B⊕B=A ⭐

```python
    return words_to_bytes(X)
```

###### **6. Round Key Generation**

```python
def generate_round_keys(key, rounds=24):
    K = list(struct.unpack('<4I', key))
```
- Convert 16-byte(128 bit) key into 4 32-bit words.
    
```python
    delta = [
        0x9e3779b9, # Golden ratio
        0x517cc1b7, # sqrt(2)
        0x428a2f98, # sqrt(3)
        0x71374491  # sqrt(5)
    ]
```
- `delta` : array in your code contains a set of four constant values.
- These constants are used in the **key schedule** of the LEA (Light Encryption Algorithm) block cipher.
- **`0x9e3779b9`**: This is a constant derived from the **Golden Ratio** (`φ`), which is an irrational number often used in cryptography to introduce a non-repetitive, pseudo-random distribution.
- Other three constants are derived from This constant is derived from **√2** (square root of 2), **√3** (square root of 3) and **√5** (square root of 5) 
- these are another irrational numbers that are commonly used in cryptography to add non-linearity and complexity (used to contribute to the mixing and diffusion of the key schedule process.)

```python
    for i in range(rounds):
        rk = [0] * 4  # Initialize a list of 4 zeros, representing the round key
        for j in range(4):
	        # Round key generation logic here
```
- Outer loop: for each round.
	- This loop iterates over the number of rounds (in this case, `rounds` would likely be 24 in the context of LEA).
	- For each round (`i`), it generates a new **round key** (`rk`), which consists of 4 words. These round keys are used in the encryption and decryption process.
	- `rounds` :  variable determines how many times the key expansion happens
	
- Inner loop: for each of the 4 words in round key.
	- This loop iterates over the 4 words (32-bit segments) in the round key (`rk`).
	- Each round key (`rk`) consists of 4 words (or 4 32-bit unsigned integers), and this inner loop generates these words using some logic based on the key schedule (mixing, rotation, XOR, etc.).
    
```python
            temp = rol(K[j], j * 5) ^ delta[j]
            temp = (temp + rol(K[(j+1)%4], j*7)) & 0xFFFFFFFF
            temp ^= (i * delta[j]) & 0xFFFFFFFF
```
- Round key derivation logic using bit rotations, additions, XORs with constants and round number.
    
```python
            rk[j] = temp
            K[j] = rol(K[j], 13) ^ temp
```
- Update round key and key state `K`.

```python
        round_keys.append(rk)
```

###### **7. Padding/Unpadding**

```python
def pad(data):
    pad_len = 16 - len(data) % 16
    return data + bytes([pad_len] * pad_len)
```
- Pads data using **PKCS-style** padding.

```python
def unpad(data):
    pad_len = data[-1]
    return data[:-pad_len]
```
- Removes padding based on last byte.
    
##### **8. Encrypt Full Image Data**
```python
def encrypt_img_data(data: bytes, key: bytes) -> bytes:
    round_keys = generate_round_keys(key)
```
- Generate keys from the provided 16-byte key.

```python
    chunks = [data[i:i+16] for i in range(0, len(data), 16)]
    if len(chunks[-1]) < 16:
        chunks[-1] = pad(chunks[-1])
```
- Break into 16-byte chunks. Pad last one if needed.

```python
    return b''.join(lea_encrypt_block(chunk, round_keys) for chunk in chunks)
```
- Encrypt each chunk, join all results.
    
###### **9. Decrypt Full Image Data**
```python
def decrypt_img_data(data: bytes, key: bytes) -> bytes:
    round_keys = generate_round_keys(key)
```

```python
    chunks = [data[i:i+16] for i in range(0, len(data), 16)]
```

```python
    return unpad(b''.join(lea_decrypt_block(chunk, round_keys) for chunk in chunks))
```
- Decrypt each chunk, join them, and remove padding.
    
---

Let me know if you want a **flow diagram** or **visual illustration** of this encryption cycle.
