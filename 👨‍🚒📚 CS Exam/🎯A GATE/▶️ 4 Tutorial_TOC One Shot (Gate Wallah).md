

### 0. Introduction 

- Decidable Problem - Problem for which Algorithm exist
- Undecidable Problem - Problem for which no Algorithm exist.
- Turing Machine Concepts is used to tell if Algorithm exist or Not for a problem

**Theory of Computation :**
- Mathematical Study of Computing Machine and their Capability
- or Study of Automata theory and formal Languages

**Automata** -> Mathematical Model or Theoretical Machine 
- Finite Automata -> Regular Language â­
- Pushdown Automata -> Context-free Language â­
- Linear-bounded Automata -> Context-sensitive Language
- Turing Machine -> Recursive Enumerable Language
### 1. Finite Automata

**Finite Automata** -> Mathematical model which contains finite numbers of `states` and `transitions`

```
                 Finite Automata
       â¬‹                           â¬Š
                
    Without output                 with output
    - DFA                        - Mealy machine
    - NFA                        - Moore Machine
    - Ïµ-NFA  
    -> Input -> Accept/Not?     ->Input->Output
    Ex: Use in Compiler       Ex:Use in Hardware
```

##### 1.1 DFA

**DFA/DEF** -> Finite Automata in which from every state on every input symbol exactly **one** transition should exist
```
DFA is defined as
DFA = (Q, âˆ‘, qâ‚€, F, âˆ‚ )
- Q : Fineite set of states
- âˆ‘ : Input alphabet
- qâ‚€ : initial state 
- F : Seto of final states
- âˆ‚ : Transition Function Q*âˆ‘ -> Q
```

> DFA Detection Questions

**Ques:** is this DFA??
```
	  b           a
	  â†·     a    â†·
 --> (q0) -----> (q1)
	      <------
	         b


Finite Set of States : {q0, q1} âœ…
Input Alphabets : {a, b} âœ…
Initial state : q0 âœ…
set of final states : {} âœ…
Transition Function âœ…

- Yes This is DFA
```

**Ques:** Is this DFA ??
```
     a,b         b  
     â†·           â†·
--->(q0)<------((q1))
           a

Finite Set of States : {q0, q1} âœ…
Input Alphabets : {a, b} âœ…
Initial state : q0 âœ…
set of final states : {q1} âœ…
Transition Function âœ…
- Yes 
```

**Ques:** Languages Generated by the DFA
```  
	      a,b
-->((q0)) -------> (q1) â¤¸ a,b

- Language Generated -> Ïµ
- for 'a....' `b....` it reach to Dead State `q1`
```

**Language** -> Any set of strings over the alphabet  `âˆ‘ = {a,b}`
ex:
- L1 = {ab, ba, abab}
- L2 = {a, ab, aba, .....}
- L3 = { } -> This represents the **empty set**, meaning it contains **no strings at all**
- L4 = {Ïµ} -> This language contains **one string**, which is the empty string Ïµ.
- L5 = {a}
- L6 = {Ïµ, a, b, aa, ab, ba, .......}

> Language Find Questions

**Ques:** Identify Language accepted by following DFA
```
	         b
--->((1))--------------> (2)
	 | Ë„ <-------------- | Ë„
   a | |        b        | | a
	 | | a      b      a | |
	 Ë… | --------------> Ë… |
	(3) <--------------- (4)
	          b

- # a's even #b's even âœ…
- # a's odd #b's even
- # a's even #b's odd
- # a's odd #b's odd

Solution : 
Minimum Language Gnerated -> Ïµ
Because Initial State is Final, and We Can Terminate Without any transition.

Its mean #a =0, #b=0 -> both even
```

**Ques:** Identify Language accepted by following DFA
```
	         b
--->(1) ---------------> (2)
	 | Ë„ <-------------- | Ë„
   a | |        b        | | a
	 | | a      b      a | |
	 Ë… | --------------> Ë… |
	((3))<--------------- (4)
	          b

- # a's even #b's even 
- # a's odd #b's even âœ…
- # a's even #b's odd
- # a's odd #b's odd

Solution : 
Minimum Language Gnerated -> 'a'
Its mean #a =1 (odd), #b=0 (even)
```

**Ques:** Identify language accepted by following DFA
```
	   0    0    0    0         
--->()-->()-->()-->()-->()  â¬Š 
	1|   1|   1|   1|   1|     â¬Š 0
	 â†“ 0  â†“ 0  â†“ 0  â†“ 0  â†“  0    â¬Š  
	()-->()-->()-->()-->() ---> () â¤¸ 0,1
	1|   1|   1|   1|   1|      â¬ˆ
	 â†“ 0  â†“ 0  â†“  0 â†“ 0  â†“    â¬ˆ 0
	()-->()-->()-->()-->(())â¬ˆ 
	â¤»    â¤»   â¤»    â¤»    â¤»
	1    1    1    1     1

- Length of the string atleast 6
- # 0's atleast 4 and # 1's exactly 2
- # 0's exactly 4 and 1's atleast 3
- None âœ…

Solution:

Minimum Language Generated = {
000011, 010001, 011000...} #1 = 2, #0 = 4
}
```

> DFA States Find for given Language Questions

**Ques :** How many states in minimal DFA for given Language `L = { a^n.b^m | n>m & n,m>=1}` â­
**Ans:**`n` & `m` Dependency Exist -> DFA Not Possible âŒ

**Ques:** How many states in Minimal DFA for given  Language `L={a^(2^n) | n>=1` â­
**Ans:** `a^2, a^4, a^8, a^16....` No common Difference between Terms -> Not Regular Language -> DFA Not Possible âŒ

**Ques:** How many states in Minimal DFA for given Language `L={a^n.b^m | n,m>=1` â­
```
L = {Ïµ, a, aa, aaa..., b, bb, bbb..., ab, abb, aabbb...}

		  a         b           a,b
		  â†·    b   â†·      a    â†·
	--> ((q0))--->((q1))------>(q2) D.S

- 3 states âœ…
```

**Ques:** How many states in Minimal DFA for given Language `L={a^n.b^m | n>=1,m>=0` â­
```
L = {a, aa, aaa..., ab, abb, aabbb...}

	  a        a          b
	  â†·  a    â†·     b    â†·
--->(q0)--->((q1))----->((q2))
	 |                      |
	 â””------->(q3)<---------â”˜
	     b     â¤»     a
	           a,b

- 4 states âœ…
```

**Length of String `|w|` -> Min no. of DFA States** â­
1. Length of the string exactly 4   -> `n+2`  (6) states 
2. Length of the string at least 5 -> `n+1` (6) states
3. Length of the string at most 4 -> `n+2`  (6) states
4. Length of the string divisible by 4 -> `n` (4) states

**No. of `#` Alphabets  `#`  Odd/Even-> Min no. of DFA States ** â­
1. # `a`'s even (Divisible by 2)-> `2` states
2. # `a`'s even (Not Divisible by 2) -> `2` states
3. # `a`'s even and # `b`'s odd -> `2*2=4` States
4. # `a`'s divisible by `3` and # `b`'s even  -> `3*2=6`


> Questions on Minimization of DFA

**Ques:** How many states present in minimal DFA for given DFA
```
	            (q3)
	 b      b    /  \   b
	 â†·      â†·  â¬‹  a â¬Š â†·
--->(q0)-->((q1))--->((q2))
	     a       <---
	               a

1. Eliminate any state which is not reachable i.e. elminate (q3)
2. Find Equivalent States, Algorithm :
	- Take All final states in one group and nonfinals in one group.
	- Non-final:{q0} Final:{q1, q2}
	- Make Transition Table
	  q | a  | b
	----|----|---
	 q0 | q1 | q2
	 q1 | q2 | q1
	 q2 | q1 | q2
	- Transition on states fall into same group?
	- q1 ->(a,b) -> {q1, q2} yes
	- q2 ->(a,b) -> {q1, q2} yes
	- if yes then q1 = q2 (Equivalent State)
	
3. Draw Minimal DFA

	 b      a,b     
	 â†·      â†· 
-->(q0)-->((q1))
     a   

- 2 states âœ…
```

##### 1.2 NFA

```
DFA is defined as
DFA = (Q, âˆ‘, qâ‚€, F, âˆ‚ )
- All Same
- âˆ‚ : Transition Function Q*âˆ‘ -> 2êŸ´
```

> NFA to DFA Questions

**Ques:** Is this DFA? If No, then how many states present in minimal state DFA for given NFA
```
	 a,b
	 â†·           b
 -->(q0)--->(q1)--->((q2))
		 a

DFA -> exactly 1 transition for each symbol

(q0,a)->q0, (q0,a)->q0 Not DFA âŒ
Also (q1,a) -> No transition -> Not DFAâŒ

NFA âœ…
```
```
Converting DFA to NFA - Draw Transition table

NFA :
   | a       | b  |
---|---------|----|
q0 | {q0,q1} | q0 |
q1 |    -    | q2 |
q2 |    -    |    |

- For empty transition, Change to Dead State
- For multiple transition, change to new state i.e. combination of q0 & q1 => [q0q1]
- If new state added, give its transition first to next entry, before remaining...

 
DFA :
       | a       | b  |
-------|---------|--------|
  q0   | [q0q1]  |   q0   | 
[q0q1] | [q0q1]  | [q0q2] |
[q0q2] | [q0q1]  |   q0   |

Min DFA - 3 States âœ…
```

**NFA to DFA Conversion**
- `n` State in NFA -> Max `2^n` States in DFA
- `n` State in NFA -> Min `1` State in DFA


**Ques:** How many states in minimal DFA for following Ïµ-NFA
```
	a,b                a,b
	 â†·   Ïµ       a     â†·
--> (q0)--->(q1)---->((q2))
      â¬†      |  â¬Š Ïµ    â¬ˆ Ïµ
	  â””------â”˜    â¬Š  â¬ˆ 
		  a          (q3)
	
						   a,b
		Ïµ      Ïµ       Ïµ   â†·
-->(q0)-->(q1)-->(q3)-->((q2))

=> Complete Language

 a,b
  â†·
((q0))

Min DFA - 1 State âœ…
```

**Ques:** Convert Ïµ-NFA to NFA â­
```
    0     (C)      1
    â†·    0â†‘ â†“1     â†·
-->(A)--->(B)--->((D))
       Ïµ      Ïµ

Without 'Ïµ' NFA?
- No. of State will remain same
- Initial state will be same
- All states from which we can reach to Final state using only Ïµ -> Make them final state

           (C)
1. (A)  (B)   (D)        Same #states

              (C)
2. -->(A) (B)   (D)      same initial state (A)

                  (C)
3. -->((A))  ((B))  ((D)) Final state {A,B,D}


4. A's Transitions
   âˆ‚(A,0) = A
   âˆ‚(A,0) = A + âˆ‚(A,Ïµ) = B
   âˆ‚(A,0) = B + âˆ‚(B,0) = C
   âˆ‚(A,0) = B + âˆ‚(B,Ïµ) = D
   âˆ‚(A,1) = D + âˆ‚(D,1) = D

    0   0 (C)    
    â†·   â¬ˆ  
-->((A))---->((B))   ((D))
    |    0             â¬†
    â””â”€-----------------â”˜
             0,1

   B's Transition
   âˆ‚(B,0) = C
   âˆ‚(B,1) = D

   C's Transition
   âˆ‚(C,0) = -
   âˆ‚(C,1) = {B,D}


    0   0   (C)    1   1
    â†·   â¬ˆ  0â†‘ â†“1  â¬Š   â†·
-->((A))---->((B))--->((D))
    |    0          1  â¬†
    â””â”€-----------------â”˜
             0,1


```


##### 1.3 Regular Expression & Regular Expression

**Regular Expression**
- The Simplest way of representing a regular language is known as Regular expression.
- For every regular language regular expression can be constructed.
- To construct regular expression following 3 operators are used.
-  `+` is known as union operator
- `.` is known as concatenation operator
- `*` is known as Kleene closure operator

- DFA can Accept Every Regular Language 
- ~ For Every Regular Language DFA can be made

**Ques:** Regular Expression for the language `L={a^n.b^n | n>=0}
```
DFA Not Possible âŒ -> Regular Expression not Possible âŒ
```

**Ques:** Construct Regular Expression that generates set of all even length palindrome string over `{a,b}`
**Ans:** Palindrome Language with More than 1 Symbol -> Regular Expression Not Possible âŒ

**Ques:** Construct regular expression that generates set of all strings of a's and b's where 4th input symbol is `b` from end â­
**Ans:** symbol at `n` from `right side -> 2^n` states
```
(a+b)* b (a+b)(a+b)(a+b)
  5    4   3    2    1

2^4 = 16 States âœ… 
```

**Ques:** Construct regular expression that generates set of all strings of a's and b's where 4th input symbol is `a` from left side â­
**Ans:** symbol at `n` from `left side -> n+2` states
```
(a+b)(a+b)(a+b) a (a+b)*
  5    4   3    2    1

4+2 = 6 States âœ… 
```

**Kleene's Closure:**

- `(a+b)*` =  `(a+b*)*` = `(a* + b*)*` = `(a* + b)*` = `(a*b*)*` complete language
- `a* + a* = a* = a*a*`
- `a+b` = `b+a`
- `a.b` != `ba`


> Final Automata to Regular Expressions Questions

**Ques:** Find Regular Expression for given F.A â­

```         
--->((q0))---a-->(q1)
	  | â†‘ <--b---- |
	b | | a        | a
	  â†“ |          â†“ 
	 (q2) ----a---> (q3)  

Remove Dead State (q3)

--->((q0))---a-->(q1)
	  | â†‘ <--b---- 
	b | | a
	  â†“ |
	 (q2)

Simplify

     ab
     â†·
-->((q0))
     â¤»
     ba

Language Accepted (ab + ba)* â­
 ```

**Ques:** Find Regular expression for given F.A?

```
      a          a
      â†·    b     â†·
 -->((q0))----->(q1)
      bâ¬‰Â      â¬‹ b
          (q2)
           aâ¤»

R.L = (a*.b.a*.b.a*.b)*
    => (a + b.a*.b.a*.b)*

```

**Ques:** Which of the following Regular Expression is equal to the given F.A
```
    b       b           b
    â†·       â†·      a   â†·
-->(q0)--->((q1))---->((q2))
                <--a---

- (a+b)*
- b*a*
- b*a(a+b)* âœ… -> b* a(b*, a, ab*, b*a.b*.a...)*
- b*a*(a+b)*

Solution by Elimination of options: 
Minimum Language Supported by F.A -> 'a'
Minimum Language supported by :
(a+b)* -> Ïµ âŒ
(b*a*) -> Ïµ âŒ
b*a(a+b)* -> `a` Could be answer
b*a*(a+b)* -> Ïµ âŒ
```

**No. of States in minimal DFA**
- `a*.b*` -> `n+1` = `2+1` = 3
- `a*.b*.c*.d*` -> `4+1` = 5
- `0*.1*.2*.....9*` -> `10+1` = 11
- `(a+b)* abab` -> ending with `n` length = `n+1` = `4+1` = 5
- `(a+b)* ababa (a+b)*` -> `n` length substring = `n+1` = 5 + 1 = 6

**Ques:** Is the Language L1 = `{a^n.b^n.c^n | n<=1000}` Regular?
**Ans:** Yes Because it is finite and have no dependency (And difference between terms in finite doesn't matter)
```
Language:
â•­------------â•®
| Regular    |
| â•­--------â•® |
| | Finite | |
| â•°--------â•¯ |
â•°------------â•¯ 

If regular -> need not be finite
If finite -> it will be regular also
```

**Ques:** Which of the following is Regular?
```
- L = {a^(n^n) | n>=1}
- L = {a^p | p is prime no. }
- L = {a^(2^n) | n>=1 }
- None âœ…

In all other options, R.E is infinite and no common difference between terms.
```

- **Reverse String** -> `w^R` is reverse of `w`
`w = abacd` -> `w^R = dcaba` 
- **Palindrome** -> `w.x.w^r`

**Ques:** Which of the following is Regular?
```
- L = {W.W^R | WÏµ(a+b)*}
- L = {W.C.W^R | WÏµ(a+b)*}
- L = {W.b.W^R | WÏµ(a)*}
- None âœ…

In all other options, R.E is infinite and and reverse dependency on each other.
```

**Ques:** Which of the following is Regular? â­
```
- L = {W.W^R.X | W,XÏµ(a+b)*} âœ…
- L = {X.W.W^R | W,XÏµ(a+b)*} âœ…
- L = {W.X.W^R | W,XÏµ(a+b)*} âœ…
- None 

In all these options, R.E is same as (a+b)* i.e. complete language and so R.L

My doubt. But this also contain infinite and dependancy ðŸ¤”â“â“
```

**Closure Properties of Regular Expression**
- Subset Operation
- Infinite Union Operation
- Infinite Intersection Operation



> Question from closure property

**Ques:** Which of the following is true?
```

1. Subset of Regular set is always Regular 
2. Subset of any Infinite set is always Regular 
3. Subset of any Non-Regular set is always Regular 
4. None âœ…

â“â“â“ change subset of to symbol
1. {a^n.b^n} subset of  (a+b)* is not regular
2. {a^n.b^n} subset of {a^n.b^n.c^m | n,m>=0} is not regular
3. {a^n.b^n} subset of {a^n.b^n.c^m} is not regular
```

> NAT Type of Questions

â“â“â“ Change Intersection symbol `L1^L2`

**Ques:** How many states present in minimal state DFA for `L1 ^ L2`  where `L1=(a+b)*a`  `L2=(a+b)*b`
**Ans:** Only 1 State
```
Intersection = {} empty set

   a,b
    â†·
-->()
```

### 2. Grammar

**Terminal** -> a, b, c, 1, 0
**Non-Terminal** -> T, S, A, B


- Set of rules used to describe strings of a language known as **Grammar**
- Formal definition of grammar is

`G = (N, T, P, S)`
- N : Non Terminals of variables
- T : Terminals
- P : No. of productions
- S : Starting symbol

â“â“ Change alpha beta to symbol
- For every language grammar exit & every grammar generates one language.
- All grammars is of a from `alpha` replacement of `alpha->Beta`, where `Beta` is replacement of `alpha`

**Derivation:**
- The process of deriving strings from the given grammar known as derivation.
- The derivation can be either left most derivation or right most derivation
- **Left Most Derivation** -> Left most non-terminal is replaced by its R.H.S part at every step
- **Right Most Derivation** -> Right most non-terminal is replaced by its R.H.S part at every step

**Derivation Tree / Parse Tree**
- Tree representation of the derivation is known as parse tree
- All leaf of the parse tree is known as `yield` of parse tree.
- While reading `yield` from left to right sentence of the grammar can be generate

```
		S
	  /   \
	 A     B                S -> AB
	 |     |                A -> a
	 a     b                B -> b
```

> Identify Language generated by grammar

**Ques:** Identify Language generated by grammar
 `S->aSa | bSb | Ïµ`
**Ans:** The Regular Language is `{W.W^R | WÏµ (a+b)*}`
```
S         S
|       / | \
Ïµ      a  S  a
        / | \
       b  S  b
          |
          Ïµ

Even Length Palindrome
```

**Ques:** Construct Grammar for the following languages. `S->aAa | bAb | a | b` , `A->aA | bA | Ïµ`
**Ans:** Starting and ending with same symbol
```
A -> aA | bA | Ïµ     => (a+b)*

S -> {a.(a+b)*.a + b.(a+b)*.b + a + b}
```

##### 2. 2 Context Free Grammar

**Ques:** Which of the following is Regular Grammar?
```
- S -> aSa | bSb | Ïµ
- S -> aSb | ab
- S -> AB, A->a , B->b
None âœ…

â“â“ Change symbol of alpha and belong to


All options 1, 2, 3 are CFG not RG

Don't Identify Grammar, using Language Rule. 
CFG can generate both Regular and non-regular language â­

Context Free Grammar : Left Side One Non-Terminal, Right Side any no. of Non Terminal
A -> alpha
albha belong to (V+T)*

Regular Grammar :Left Side One Non-Terminal,  Right side atmost 1 non-terminal
A -> xB | x : Right linear Grammar
A -> Bx | x : Left Linear Grammar

```


**Ambiguous Grammar** -> For at least one string more than one Parse tree exist.
- Verification of Ambiguity is undecidable problem i.e. no algorithm exist

Ambiguous Ex: 
```
S -> AA
A -> aA | a

          aaa
         â¬‹   â¬Š
    S             S
   / \           /  \
  A  A           A   A
  |   |          |  / \
  a   A          a  a  A
      |                |
      a                a
```

**Ques:** Which of the following is Unambiguous Grammar
```
- S -> SS|Ïµ
- S -> aSbS|bSaS|Ïµ
- S -> AaAb | BbBa, A->Ïµ , B->Ïµ âœ…
- None
```

**Normal Form of CFG**
1. Chomsky Normal Form
2. Greibach Normal Form
****
### 3. Push Down Automata

##### 3.1 Context Free Language

### 4. Turing Machine

### 5. Undecidability